---
title: 图片最小重复单元
description: "怎样从一个平铺的图中找到最小重复的那个图？"
layout: post
excerpt_separator: <!--more-->
image:
  feature: post/head/photo-1493407192204-530f0ce3d3d2.jpeg
---

很多时候我们会看到一个大图是由很多很多重复出现的小图平铺而成的，就像我们人行道上的砖块，每一个砖块就是一个重复单元，然后很多砖块一起铺成人行道，于是每个砖块就可能是一个最小重复单元（具体情况得看每个砖块上的图形）。于是情况是这样的，给你一张很大的图，找出这个图片最小的那个重复单元，如果没有那整个大图就是一个最小重复单元。

<!--more-->

### 为什么要找最小重复单元

前端开发中，我们都知道如果一个背景是由一个小图平铺而成，那么我们不用使用一张完整的大图而是只需要用这个小图进行平铺就好，这样就节省了网路的流量开销，同时也加快页面加载速度，这个没什么好说的。

问题在于，设计给设计稿时，如果这个背景图是由一个小图平铺而成的，他是不会给你这个最小重复单元的图的（或是没想到或者不知道），于是在切图的时候就需要截取这个最小重复单元，有些图很容易用肉眼看出来哪个是最小重复单元，然后用PS随便截取一个就好了，但是就是有那么些图肉眼看就没那么轻松，又觉得不好去麻烦设计给这个最小重复单元的图，于是就想自己来做一个可以自动寻找到这个最小重复单元的小程序。

### 怎样找图片最小重复单元

HTML5的新标准，引入了canvas画布功能，具体不再多说。

浏览器的canvas画布功能提供了一个方法[getImageData()](http://www.w3school.com.cn/tags/canvas_getimagedata.asp)，这个方法是返回当前画布的像素信息，即每个像素点的RGBA值，然后我们可以将这4个值用16进制的字符拼接成一个字符串，就可以唯一标识该像素点，然后将画布的每个像素映射到一个二维数组中，于是我们就可以将寻找图片最小重复单元转化成寻找一个二维数组的最小重复单元。

在开始之前，先确定一个思想，就是所给的图片既然是以一个小图平铺的，那么这个最小重复单元是有很多种情况的，但是只要我们确定了这个最小重复单元的长和宽就可以了。

![demo](https://image-1257141638.cos.ap-guangzhou.myqcloud.com/post/mini-repeat-01.jpg)

 

如上图所示，A、B、C中每个绿色小方块都可以是最小重复单元，所以不局限是图A那种。于是这样就可以不用在意每个重复单元的起点，所以我们就可以方便的以大图的左上角为第一个最小重复单元的起始位置，剩下的只要确定这个最小重复单元的长和宽就可以了。

### 如何确定长和宽

我们把问题再细分，找到最小重复单元其实可以假设这个大图的高是一像素，然后宽是任意，于是这就变成了在一维数组中寻找最小重复项，问题就变得简单多了。

具体的算法，我的思路是遍历原数组A，然后最小重复单元用数组B存放，先将A中的第一个元素放入B中，然后B依次和A中后面的元素比较，当遇到不匹配时，则对B中的元素进行一次调整。这里的调整分两种情况：

1. 当B与A之后的元素完全匹配1次或1次以上后遇到不同的，则新的B数组是从A数组的0位置开始到当前A中不匹配元素位置止。
2. 当B与A之后的元素没能完全匹配1次，则新的B数组是按在A中的顺序向后增加一个元素。

具体如下说明：

对于情况一：

假设A数组是`A=[1,1,1,2,1,1,1,2,1,1,1,2,1,1,1]`，那么当循环开始的时候B数组中是A数组中的第一个元素，即`B=[1]`。然后依次和A中后面的元素比较：

`A[1]==B[0]`（一次完全匹配）

`A[2]==B[0]`（一次完全匹配）

`A[3]!=B[0]`（匹配失败）

此时匹配失败，那么此时B和A中的元素已经完全匹配了2次，于是此时将B数组修改为从0开始到A数中中当前不匹配的元素的位置，即B=[1,1,1,2]，再一次往后匹配：

`A[4]==B[0]`

`A[5]==B[1]`

`A[6]==B[2]`

`A[7]==B[3]`（一次完全匹配）

`A[8]==B[0]`

`A[9]==B[1]`

`A[10]==B[2]`

`A[11]==B[3]`（一次完全匹配）

以此类推

对于情况二：

假设A数组是A=[2,2,1,2,2,2,1,2,2,2,1,2,2,2,1,2]，那么当循环开始的时候B=[2]，依次和A后面元素比较：

`A[1]==B[0]`（一次完全匹配）

`A[2]!=B[0]`（匹配失败）

此时已经完全匹配过一次，于是B=[2,2,1]，再依次向后匹配：

`A[3]==B[0]`

`A[4]==B[1]`

`A[5]!=B[2]`（匹配失败）

此时还未进行一次完全匹配，于是现在将B修改为按A的顺序向后增加一个元素。即B=[2,2,1,2]（而不是修改为从0开始到A数中中当前不匹配的元素的位置B=[2,2,1,2,2,2]）。然后从所增加的这个元素后一位开始匹配：

`A[4]==B[0]`

`A[5]==B[1]`

`A[6]==B[2]`

`A[7]==B[3]`（一次完全匹配）

`A[8]==B[0]`

`A[9]==B[1]`

`A[10]==B[2]`

`A[11]==B[3]`（一次完全匹配）

依此类推

这样就可以找到在一个数组中最小的重复单元，即全部都可以完全匹配时的数组B，至于这个算法是不是高效的，就没有深入研究了，如果你有兴趣可以帮忙看看。

然后再应用到二维数组中，其实可以完全看成一个一维数组，只不过这个数组中所存放的元素是数组，要进行比较的也就变成数组的比较了，这样就可以确定这个二维数组的最小重复单元的宽了，然后同样的再以高的方向遍历一遍，也就可以得出最小重复单元的高了。

大致的思路就是如此。

具体代码实现demo：[http://demo.maple.im/min-repeat/](http://demo.maple.im/min-repeat/)

